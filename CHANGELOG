FROM 1.4 to 1.5 
---------------
New features:
    - add Subtyping functionnality (in file jType).
    - HeapInspector:  C library (.so) using JVMTI allowing to dump the heap at
      the initialization of a program. This is a utility to get an initial
      state more precise and correct than the bottom initial state.
    - heap_parser: Ocaml code to parse to dump generated by HeapInspector and
      to integrate it in Sawja analysis.
    - jRTAWithHeap: A version of RTA using the Heap inspector dump to get more
      precise program.

Minor Changes: 
    - Add function directly_implemented_interfaces returning only the
      interfaces directly implemented (used by the subtyping).
    - Add a function get_callgraph_from_entries only computing the reachable
      part of the callgraph (from a given entry point).
    - Add a function resolve_all_field returning a program where all fields
      have been resolved (or throw AmbigousFieldResolution).
    - Safe: The analysis using Safe can now throw DebugDom exception, allowing
      to dump the current state while the fixpoint is not reached (usefull for
      debug).
    - Program Pointer (PP) system rewriting: Create 4 modules (jBirPP(SSA),
      a3BirPP(SSA)) which reuse as much as possible a common PP module.
    - HTML printing: Exceptions are now printed in html dump.

Bug fixes:
    - Clean code: correct warning given by Ocaml 4.0.1
    - Safe: Abstraction of local variables: function set_var now distinguish
      between Bot and an empty map of local variables. Bot means unreachable
      and so a set_var on a Bot local variable map stay to Bot.
    - jProgram: static_lookup new consider 'new' instruction as it is both an
      allocation and a call to the constructor.
    - jCRA: ClassNotFound exception is now public. if there is some missing
      class whilie we try to build program, we throw this exception. This can
      help to get the name of the missing class.

From 1.3 to 1.4
---------------
New features:

* Formula: allows to give a special meaning to some user defined functions.
  This function takes as parameter a boolean variable. The expression used to
  build this parameter is matched by Sawja and can then be used to make
  assertions in an analysis.

Licence change: 

* Sawja is now GPL instead of LGPL.

Minor Changes:

* JProgram: add functions map_program_with_native* which provide a way
  to transform the implementation type.

* JBir/A3bir/JBirSSA/A3BirSSA: 
  - Some cleaning and factorization between the different IR.

  - Modules JControlFlow.PP_* for those IR were removed since those
    kind of services must be provided by the IR modules if necessary

* A3Bir: The instruction only have variables as arguments and no more
  variables or constants (use a type tvar instead of basic_expr).

* Remove installation option '-l default'.

* Documentation:
    Various improvements and updates.

Bug fixes:

* IR: 
  - Remove short and byte from const type as they are replaced by int
  values at this level.

  - In case of generation of a MayInit, some heap sensible elements
    were not replaced in the stack.

  - CheckLink instructions were sometimes generated twice (only
    generated when option ~ch_link is activated during
    transformation).

  - CheckLink was generated before a "new" instruction even if ch_link
    option was not activated

  - BCV: A java code using a variable considered as "Null" could lead to a crash
    during the transformation. The "Null" type has been clarified.

  - Dead code elimination: The code of an exception handler only accessible
    from itself was not considered as dead code and could even lead to a bug.

  - JBirSSA and A3birSSA: 
      - function "vars" now returns a ptmap instead of an array (because SSA
        variable indexes doesn't start at 0).
      - Add a function "ssa_index" returning the index of the first SSA variable
        and of the last SSA variables.
  
* availableExpr : a variable was not killed when it was assigned with an
  expression not usable for available expression (side effect expressions)

* JRTA: raises an exception when no entry points are found.

* JControlFlow.PP_* modules: throw instructions were badly handled (they
  were treated the same as others instructions that can throw only native
  exceptions)

* jvmti: CallsTracer now works on 64bits system. Remove compilation warnings.

* Various fixes in Makefile and htmlPrinter.

From 1.2 to 1.3
---------------
New features:

* An Eclipse plugin for Sawja analyzes is now available (update site:
  http://javalib.gforge.inria.fr/plugin): it allows developers to add
  an analysis in Eclipse just by adding an executable. The modules
  ArgPlugin and JPrintPlugin were added and provide the interfaces to
  build a compatible executable for the plugin (see Sawja tutorials on
  website)

Minor changes:
* JProgram: 
  - add several iterators for methods and fields
* JPrintHtml:
  - provide a function to print a class (even without a complete
    program)
  - add printers for intermediate representations in SSA forms
* IR: 
  - add a [get_source_line_number] function
* Documentation:
  - Add fixpoint solvers and examples on the API documentation main
    page
* The BDD library (Buddy) is now statically linked it
* Compilation of documentation (make doc) does not need lynx anymore

Bug fixes:
* Some program points were missing in the correspondence map from
  JCode representation to intermediate representations
* Function [var_name_debug] was missing in the SSA forms of
  intermediate representations
* The analysis on debug information for local variables, launched
  during transformation to intermediate representations, does not
  return false positive on consistent information anymore
* The Java string constants were not escaped before manipulation. We
  now have an abstract datatype JBasics.jstr, and the corresponding
  setter and getter functions
* Fix Sawja makefile for GNUMake <= 3.80: a blank character was
  considered as an element of the list of modules
* Fix some checks in configure script
* Fix some broken links in documentation

Known bugs: 
* Program discovery does not take reflection into account
* Native methods are only handle by RTA and may only be under 
  approximate with our stub generator, or under or over approximate by
  hand
* Inlining of subroutines does not allow to keep correspondence
  between program points and line numbers
* JControlFlow.PP_* modules are not taking into account exceptions
  that could be thrown by a "Throw" instruction in the [handlers] and
  [exceptional_successors] functions

From 1.1.1 to 1.2
-----------------

New features:
* Add pruned SSA (Static Single Assignment) form for JBir and A3Bir
  representation
* JControlFlow:
  - Add modules PP_* to access and navigate in code for all IRs (JBir,
    A3Bir, JBirSSA, A3BirSSA).
* JProgram: map_program functions allow to update the
  static_lookup_method of a program by giving program point
  correspondance between new and old code representation
* JBir & A3Bir: add VarSet and VarMap modules for variable type: their
  implementation is based on Patricia trees which are much more
  efficient than the balanced trees of OCaml
* Add some dataflow analyses examples: available expression, reachable
  defenition, live variable
* Integration of the module buddycaml in Sawja distribution that
  allows to bind the BDD package, BuDDy (C library), to caml (could be
  used in Sawja using option configure.sh -b yes).

Bug fixes:
* JBir & A3Bir: 
  - MayInit instructions were not generated for OpPutStatic
    instructions (when a static field was not in the stack)
  - Intermediate representations were using only one name per local
    variable (e.g. local variable '2') when debug info was
    available. Now it uses correctly the local_variable_table
    information (N.B: debug info is checked during transformation and
    could be rejected if it is inconsistent).
* JBir: 
  - Check (CheckArithmetic) was not generated on OpDiv and OpRem instructions
* JControlFlow: 
  - overrides_methods function did not work and could not terminate
  - resolve_all_interface_methods implementation did not correspond to
    description in documentation, now it does
* JPrintHtml:
  - arguments displayed on invoked methods were those of current
    method instead of invoked methods
  - arguments numbers were not correct: receiver was not taking in
    account in non-static methods
* XTA and ReachableMethods: Sys.max_array_length value was used to
  initialize some XTAState domains. On 64bits systems it could leads
  to an Out_of_memory exception. Those values are replaced by
  constants.

Minor changes:
* JBir & A3Bir: 
  - Add a "CheckLink of JCode.jopcode" in check assertion
    generated by JBir and A3Bir, this type of check is only generated
    if the option 'ch_link' is activated during transformation of
    code. It indicates when linking operations are done and then could
    eventually fail.
  - Check (CheckArrayStore _) was generated on all OpArrayStore
    instruction, now it is not generated if OpArrayStore store a
    primitive type.
  - Check (CheckArithmetic _) was generated on all OpDiv and OpRem
    instructions, now it is not generated if operand has type float or
    double.
  - If an instruction has no possible predecessor it is removed during
    transformation
* JControlFlow:
  - Acces and navigation in JCode representation is put in module
    PP_BC
* JPrintHtml: 
  - add return type of invoked methods on display
  - arguments types of caller methods of a method are now displayed
* Safe:
  - Domain.Local: improve management of bot values
  - State: add functions to could iterate on analysis result and to
    modify it (must not be used during analysis!)

Known bug: 
* Program discovery does not take reflection in account
* Native methods are only handle by RTA and may only be under 
  approximate with our stub generator, or under or over approximate by
  hand
* Inlining of subroutines does not allow to keep correspondance
  between program points and line numbers


From 1.1 to 1.1.1
------------------

Minor changes: 
* RTA, RRTA, XTA: a default list of subclasses of java.lang.Throwable
  that can be instantiated and thrown by the JVM is provided. This
  list may be used by RTA, RRTA and XTA.
* XTA: add the optional argument '~native_throwable' that allows to
  specify the subclasses of java.lang.Throwable that may be
  instantiated and thrown by the VM

Bug fixes:
* RRTA: the type of the receiver was not taken as possible parameter
  in virtual methods
* XTA: arrays were not correctly abstracted
* RRTA and XTA: exception handlers were not taken in account
* BIR: bugfix in printing functions
* FindLib META file had not been updated with the release (was
  indicating version 1.0.1 instead of 1.1, now updated to 1.1.1)
* XTA: OpConst(Class _) and OpConst(String _) instructions were not
  considered as instantiations of java.lang.Class and java.lang.String
* RTA, RRTA: OpConst(String _) instruction was not considered as
  an instantiation of java.lang.String, now it is
* JPrintHtml: bugfix in print_jbir_program and print_a3bir_program for
  method lookup

Known bug: 
* Program discovery does take reflection in account
* Native methods are only handle by RTA and may only be under 
  approximate with our stub generator, or under or over approximate by
  hand

From 1.0.1 to 1.1
------------------

Compilation & Installation changes:
* installation process now rely on Findlib (more homogeneous installation,
  easier to use as dependencies are automatically linked in)
* add a configure script into the compilation routine that automatically
  generate the appropriate Makefile.config file. Local installation is now an
  easy option

New features:
* add JsrInline, a module which allows to in-line most subroutines (all but
  nested ones)
* BIR code representation is now flatten and represented as an array.
  Correspondence tables between bytecode (JCode) and BIR have been added.
* add a call graph computation algorithm with different level of sensitivity
  (ranging from MTA to XTA) (see documentation in XTA)
* add a module Safe, a static analysis framework, which provides a fixpoint
  iterator, domain composition, standard containers for method, fields, class
  and program points, etc.
* JVMTI which can be use to add static information on native method during
  program discovery (RTA, CRA).

Minor changes:
* IR changes:
  - add a ~bcv flag (to [transform] functions in JBir and A3Bir) which run a
    ByteCode Verifier
  - new exception_handler type, a specific catch var is created for each handler
  - add printing functions (string and for JPrintHTML)
  - var is now indexed
  - structural equality (=) can be used on var (but var_equal function is
    faster)
* RTA changes:
  - add a list of default instantiated classes and abstract entry points
  - more classes are now loaded: catch type of handlers and field types of
    loaded classes are loaded (even if not accessed)
* add static_lookup_special function in JControlFlow (for invokespecial
  instruction)
* module JPrintHTML is now generic with respect to the implementation of methods
* the documentation of Sawja now includes the documentation of the
  user-interface of Javalib for cross-references (Javalib, JBasics and JCode)
* zip can be used where jar were expected
* improve documentation and tutorial

Bug fixes:
* fixes some CSS bugs
* bugfix on arrayload types of BIR representations
* correct handling of local variable names (debug option) in JPrintHTML.
* CheckArthimetic was missing in jBir
* a Cast unary operator was missing in jBir

Known bug:
* Program discovery does not include native methods and reflection
* Inconsistencies between results of XTA, RTA, RRTA and CRA.

From 1.0 to 1.0.1
----------------
Minor fixes:
* typos in documentation / tutorial / quick start
* better error handling in JPrintHtml
* providing style.css which was missing (looks better in JPrintHtml)
* installation procedure should run more smoothly

Initial release 1.0
--------------------
This initial version features a fork from Javalib 1.8.1 where the code
concerning the program representation and manipulation has been moved from
Javalib to SAWJA.  From Javalib 1.8.1, The main improvements includes the
bytecode transformations, the overall efficiency (more lazy stuff, indexed data,
caches, etc.) and the cleanner interfaces and documentation.

Main features:
* Program representation where the bytecode (method) representation can be
  modified
* Intermediate bytecode representation (bytecode with expressions and without
  stack and 3 addresses code)
* Control flow manipulation (resolution of classes, fields and methods, static
  over approximation of lookups, etc.)
* Program discovery with RTA (Rapid Type Analysis), CRA (Class Reachability
  Analysis) and RRTA (Refine Rapid Type Analysis)
* Stub generation for object allocation for native methods from concrete
  execution
* Program pretty printing as text or HTML output
